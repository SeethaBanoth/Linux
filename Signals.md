**1. Can you explain the concept of signals in programming? How are they used in Unixlike operating systems?**

A. Signals in programming are asynchronous notifications sent by the operating system (OS) to a running process to inform it of specific events, like a user interrupt or an error condition. Think of them as urgent text messages that interrupt the program's normal flow, prompting it to react immediately.



**Signals in Unix-like Systems**

In Unix-like OSes (Linux, macOS, BSD), signals are a core inter-process communication (IPC) mechanism standardized by POSIX. The kernel delivers them to processes or threads, pausing execution to handle the event—common ones include SIGINT (Ctrl+C interrupt), SIGTERM (polite termination request), SIGKILL (forceful kill, unblockable), and SIGSEGV (memory access violation).\[ from prior context]



Processes can ignore, catch (via handlers), or accept defaults like termination. Signals use small integers (1-31 or more) as IDs, sent via commands like kill or events like timers expiring.



**How Signals Are Generated and Used**

* Sources: Keyboard (Ctrl+C → SIGINT), other processes (kill -9 PID → SIGKILL), hardware (divide-by-zero → SIGFPE), or timers (alarm() → SIGALRM).



* Delivery: Kernel queues pending signals; unblocked ones trigger handlers or defaults when the process is scheduled.



* Handling: Use signal() or sigaction() to register custom functions, block with sigprocmask(), or check pending ones via sigpending(). Example: Servers use SIGTERM for graceful shutdowns, saving state before exit.\[ from prior context]



**Practical Examples**

* Graceful Exit: Catch SIGINT/SIGTERM to clean up files or connections.



* Debugging: SIGTRAP for breakpoints in debuggers.



* Limitations: Handlers must be quick and async-safe; can't rely on malloc or complex I/O.\[ from prior context]

​



This setup makes Unix programs robust against interruptions while allowing controlled responses.



**2. What are software interrupts and hardware interrupts and mention potential issues**

**when dealing with them?**

A. Software interrupts and hardware interrupts are mechanisms that pause a CPU's normal execution to handle urgent events, saving and restoring the processor state as needed.



**Hardware Interrupts**

These are triggered by external physical devices or internal hardware events, like a keyboard press, disk completion, or timer expiration. They are asynchronous, meaning they can occur at any unpredictable time, prompting the CPU to jump to an interrupt service routine (ISR) after pushing registers onto the stack and disabling further interrupts temporarily.



**Software Interrupts**

These are deliberately generated by software instructions (e.g., INT in assembly or system calls), acting like a synchronous "call" to the OS kernel for services such as file I/O or exceptions like division by zero. Unlike hardware ones, they increment the program counter predictably and often have higher priority.



**Key Differences**

**Aspect	              Hardware Interrupt	         Software Interrupt**

Trigger	            External devices/timers	      Program instructions/exceptions

Timing	             Asynchronous (anytime)	     Synchronous (specific code points)

Priority                 Generally lower	               Often higher

Handling	  Disables interrupts, stack push	    Like subroutine call

​

**Potential Issues**

* **Race Conditions:** Asynchronous hardware interrupts can interrupt critical code sections, corrupting data if not masked properly.



* **Priority Conflicts:** Nested interrupts or poor prioritization may starve important tasks or cause stack overflows from deep nesting.



* **Latency:** Long ISRs (especially software ones with complex ops) delay other processes; hardware ones risk missing events if too slow.



* **Reentrancy:** Handlers assuming non-interruption (e.g., using non-atomic ops) fail under concurrency, leading to crashes.

​



Proper design with masking, atomic sections, and short handlers mitigates these in Unix-like systems, tying into signals as software-emulated interrupts.



**3. What is synchronous signal and asynchronous signal and how the process can be used**

**for both?**

A. Synchronous signals are generated by the current process at precise, predictable points during its execution, often due to faults or traps like division by zero (SIGFPE) or invalid memory access (SIGSEGV). Asynchronous signals, in contrast, arrive unpredictably from external sources, such as another process sending SIGTERM via the kill command or a timer expiring (SIGALRM).



**Key Differences**

**Aspect	         Synchronous Signals	                Asynchronous Signals**

Timing	         Tied to specific instructions	        External events, any time

Predictability	 Deterministic (e.g., after bad code)	Non-deterministic

Examples	 SIGILL (illegal instruction), SIGBUS	SIGINT (Ctrl+C), SIGTERM, SIGCHLD

Delivery	 Immediately after fault       	        Queued until process checks/runs



**Handling Both in a Process**

A single process can receive and handle both types uniformly using signal handlers registered via signal() or sigaction(). The kernel delivers either type to the process, which pauses normal execution, runs the handler (passing the signal number), and resumes—unless blocked via sigprocmask(). For instance, a program might catch SIGSEGV (synchronous fault) to log errors and SIGTERM (asynchronous) for cleanup; pending signals are checked on return from syscalls or kernel mode.



**4. Who is responsible for generating signals?**

A. The operating system kernel is primarily responsible for generating signals in Unix-like systems, though other processes and hardware also contribute.



**Kernel's Role**

The kernel detects events like hardware exceptions (e.g., divide-by-zero → SIGFPE), timers expiring (SIGALRM), or child process termination (SIGCHLD), then generates and delivers the signal to the target process. It manages signal queues, masks, and delivery timing.



**Other Sources**

* **Hardware:** Triggers synchronous signals via CPU-detected faults, like invalid instructions (SIGILL) or memory violations (SIGSEGV); kernel translates these.



* **Processes:** Any process (including self) can send signals to another using kill(pid, sig) or raise(sig) for self-signaling.



* **User Actions:** Keyboard events like Ctrl+C (SIGINT) or Ctrl+Z (SIGTSTP) are caught by the terminal driver and passed to the shell/kernel.



**Delivery Process**

Kernel checks the target's signal disposition (ignore, default, handler) from its process control block before acting—e.g., queuing if blocked or invoking the handler.



**5. What is signal handler?**

A. A signal handler is a user-defined function in a program that the operating system automatically invokes when a specific signal is delivered to the process. It allows the program to respond customly to events instead of relying on default behaviors like termination.



**How It Works**

When the kernel generates a signal (synchronous or asynchronous), it pauses the process's normal execution, saves the current state (like registers and program counter), and jumps to the handler function registered for that signal number. The handler receives the signal's integer code as input, performs actions (e.g., cleanup or logging), then returns—resuming the process from where it was interrupted.



**Registration Methods**

Use signal(signum, handler) for simple cases or sigaction() for advanced control (masks, flags). Handlers can be:



* Custom function: void handler(int sig) { /\* code \*/ }



* SIG\_IGN: Ignore the signal.



* SIG\_DFL: Default action (e.g., terminate).



Keep handlers short and "async-signal-safe" (avoid malloc, printf in loops) to prevent deadlocks or corruption



**6. Which system call is used to send a signal to the process?**

A. The primary system call used to send a signal to a process in Unix-like systems is kill() (specifically kill(2)).



**Key Details**

* **Prototype:** int kill(pid\_t pid, int sig); where pid identifies the target (positive PID for a process, 0 for process group, -1 for all eligible processes), and sig is the signal number (e.g., SIGTERM=15).



* **Usage:** A process sends signals to others (or itself) if permissions allow; the shell kill command invokes this syscall underneath.



* **Alternatives:** raise(sig) sends to the calling thread/process (library wrapper around kill), and pidfd\_send\_signal() for pidfds in modern Linux.

​



This enables inter-process signaling for termination, pauses, or custom events.



7\. Write a program to send a signal to itself (same process)?

A. Here's a simple C program that sends a signal (SIGUSR1) to itself using raise() or kill(getpid(), sig), with a handler to catch and demonstrate it.



**Complete Program**



*#include <stdio.h>*

*#include <signal.h>*

*#include <unistd.h>  // for getpid()*



*void handler(int sig) {*

    *printf("Caught signal %d (SIGUSR1) in the handler!\\n", sig);*

    *// Perform cleanup or other actions here*

*}*



*int main() {*

    *// Register the signal handler for SIGUSR1*

    *signal(SIGUSR1, handler);*



    *printf("PID: %d. Sending SIGUSR1 to myself...\\n", getpid());*



    *// Send the signal to itself (two equivalent ways)*

    *// Method 1: Using raise() - simplest for self-signaling*

    *raise(SIGUSR1);  // Triggers handler immediately*



    *// Method 2: Using kill() with own PID (equivalent)*

    *// kill(getpid(), SIGUSR1);*



    *printf("Back in main() after signal handling.\\n");*

    *return 0;*

*}*



<b>How to Compile and Run</b>



*gcc -o self\_signal self\_signal.c*

*./self\_signal*



<b>Expected Output</b>



*PID: 12345. Sending SIGUSR1 to myself...*

*Caught signal 10 (SIGUSR1) in the handler!*

*Back in main() after signal handling.*



<b>Explanation</b>

* **Handler Registration:** signal(SIGUSR1, handler) tells the kernel to call handler() when SIGUSR1 (signal 10) arrives.



* **Self-Signaling:** raise(SIGUSR1) is a library function specifically for sending signals to the current process/thread. It's equivalent to kill(getpid(), SIGUSR1).



* **Execution Flow:** Main prints, sends signal → kernel pauses main, calls handler → handler prints and returns → main resumes.



**Why Use raise()?**

* Cleaner than kill(getpid(), ...) for self-signals.



* Thread-safe in multi-threaded programs (delivers to calling thread).



* Portable across Unix systems.



This demonstrates the full cycle: handler setup, self-signal generation, and resumption—perfect for testing signal behavior safely.



**8. Explain the default action associated with the SIGKILL signal?**

A. SIGKILL's default action is unconditional process termination by the kernel, with no opportunity for cleanup.



**Core Behavior**

When SIGKILL (signal 9) is delivered, the kernel immediately kills the process without invoking any user handler, ignoring attempts to block, catch, or ignore it—this is by POSIX design to ensure forcible termination. The process vanishes from the process table; open files may not flush, memory is reclaimed abruptly, and no atexit handlers run.



**Why Uncatchable**

Unlike SIGTERM (which allows graceful exit), SIGKILL bypasses user space entirely: kernel mode reaps resources directly, preventing hangs or loops from blocking shutdown. Use kill -9 PID only as last resort after SIGTERM fails.



**Implications**

* **Data Loss:** Unsaved buffers, unflushed logs, or mid-write corruption.



* **No Recovery:** Child processes become orphans (adopted by init); IPC locks may persist.



* **Delivery Guarantee:** Queued if blocked elsewhere, executed on next scheduling.\[ from prior]



**9. How does a process handle a signal while it is executing in kernel mode?**

A. Processes cannot execute user-defined signal handlers while running in kernel mode; signals are queued and handled only upon returning to user mode.



**Signal Delivery Timing**

When a process enters kernel mode (e.g., during a system call like read()), the kernel marks incoming signals as pending but defers delivery until the process exits kernel mode back to user space. This happens at specific "safe points": after syscalls complete, during context switches (via timer interrupts), or post-interrupts—ensuring the handler runs in the process's user-mode context with a stable stack.

**Kernel's Handling Process**

* **Queuing:** Kernel adds signal to the process's sigpending bitmask in its task\_struct.



* **Check on Exit:** Functions like handle\_signal() or do\_signal() scan for pending, unblocked signals just before returning to user mode.



* **Setup and Jump:** Kernel tweaks the user stack to invoke the handler (like a forced function call), saves state, runs it, then restores original execution.



**Exceptions for Kernel Processes**

Kernel threads (no user context) poll manually via sig\_chk() and handle signals directly without user handlers—user processes always defer to user mode.

**Why This Design?**

Prevents corruption: Kernel mode lacks user stack access, and interrupts could nest dangerously. In preemptive kernels like Linux, timer interrupts guarantee eventual checks even for long-running syscalls.



**10\. Describe the behaviour of a process when it receives a SIGSEGV signal?**

A. When a process receives SIGSEGV (signal 11, segmentation violation), it typically terminates abnormally due to invalid memory access, like dereferencing a null pointer or accessing protected memory.

**Default Behavior**

Without a custom handler, the kernel's default action for SIGSEGV triggers immediate process termination. The process dumps core (if enabled via ulimit -c), freeing resources abruptly—no cleanup, atexit handlers, or flushes occur. Exit status reflects signal death (e.g., 128 + 11 = 139).\[ from context]

**Custom Handling**

Processes can catch SIGSEGV with signal(SIGSEGV, handler) or sigaction(), allowing recovery (e.g., fix stack, log error) or graceful exit. Handlers run in process context but must avoid further faults; returning normally resumes from the violation point (risky). Common in debuggers or fault-tolerant apps.

**Detection in Parent**

Parents use waitpid(): if (WIFSIGNALED(status) \&\& WTERMSIG(status) == SIGSEGV) confirms child crashed on segfault.

This synchronous signal arises from CPU-detected hardware faults, ensuring quick response to memory errors.



**11\. What is the role of the sigwait() function in signal handling?**

A. The sigwait() function enables a process or thread to synchronously wait for and consume specific blocked signals, treating asynchronous events as predictable blocking calls.

**Core Role**

sigwait(const sigset\_t \*set, int \*sig) suspends the calling thread until one signal from the specified blocked set becomes pending, then atomically removes it from the pending queue and stores its number in \*sig. This avoids async handlers, making signals behave like condition variables—ideal for multi-threaded synchronization or servers polling for SIGCHLD/SIGTERM.



**Key Requirements and Behavior**

* Signals in set must be blocked beforehand via pthread\_sigmask() or sigprocmask(); otherwise, behavior is undefined.

* No handler invocation: sigwait() dequeues the signal directly, preventing default actions or user handlers.

* Multiple waiters: Only one thread consumes the signal (first-come, first-served).

* Returns 0 on success, -1 on error (e.g., EINVAL for unblocked signals).

**Common Use Case**

In threaded apps, mask signals process-wide, let worker threads sigwait() in a loop for events like child exits, while avoiding race-prone async handlers:

*sigset\_t set;*

*sigemptyset(\&set);*

*sigaddset(\&set, SIGUSR1);*

*sigprocmask(SIG\_BLOCK, \&set, NULL);*

*int sig;*

*sigwait(\&set, \&sig);  // Blocks until SIGUSR1 arrives*

This provides reliable, handler-free signal handling.



**12\. Explain the concept of signal correlation in a distributed environment?**

A. Signal correlation in a distributed environment refers to linking and analyzing related observability signals (logs, metrics, traces) across multiple services, hosts, or microservices to trace request flows, detect anomalies, and pinpoint root causes of issues.

**Core Concept**

In distributed systems like cloud-native apps or Kubernetes clusters, a single user request spans dozens of services. Each generates independent signals without inherent connection. Correlation assigns unique identifiers (e.g., trace IDs, request IDs) propagated through the request path, enabling tools to reconstruct the full journey and correlate events like a slow database query causing frontend timeouts.

**How It Works**

* **Propagation:** Services extract ID from incoming headers (e.g., W3C Traceparent in OpenTelemetry), add their spans/logs/metrics tagged with it, and forward to downstream services.

* **Collection:** Centralized systems (ELK Stack, Jaeger, Prometheus with Grafana Tempo) index by ID, allowing queries like "show all signals for trace ID xyz".

* **Analysis:** Rules or ML detect patterns—e.g., correlating error spikes in Service A with latency in Service B.

**Challenges**

* **Incomplete Propagation:** Missing IDs break chains (firewalls, legacy services).

* **Volume:** Billions of signals; efficient indexing/querying needed.

* **Cross-Domain:** Logs/metrics/traces in separate stores require unified querying.

**Example Workflow**

* API Gateway generates trace-id: abc123.

* Payment service logs "processing abc123" + metric latency=500ms.

* Database traces span abc123: query timeout.

* Observability dashboard correlates: Gateway → Payment → DB failure.

This transforms siloed data into actionable insights, far beyond Unix process signals.

13. Explain how a process handles a signal while it is in the ready state?
A. 


